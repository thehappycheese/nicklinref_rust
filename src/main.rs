use std::{sync::Arc, net::SocketAddr, error::Error};
use clap::Parser;
use warp::{Filter, wrap_fn, Reply, reply::Response, filters::BoxedFilter, fs::File};

mod helpers;

mod routes;

mod data;
use data::IndexedData;

mod settings;
use settings::Settings;

/// in order to facilitate testing of warp routes we cannot build them in
/// `fn main`
async fn build_routes(settings:&Settings) -> Result<BoxedFilter<(Response,)>, Box<dyn Error>> {

    // Load data
    let indexed_data:Arc<_> = IndexedData::load(
        &settings.NLR_DATA_FILE,
        &settings.NLR_DATA_SOURCE_URL,
        &settings.NLR_FORCE_UPDATE_DATA
    ).await?.into();

    let route_static_folder = warp::fs::dir(settings.NLR_STATIC_HTTP.clone());
    let route_show = warp::path("show").and(route_static_folder);
    let route_lines = routes::lines(indexed_data.clone());
    let route_points = routes::points(indexed_data.clone());
    let route_lines_batch = routes::lines_batch(indexed_data.clone());

    let x = route_show.map(|r:File| r.into_response()).or(
        route_lines
        .or(route_points)
        .or(
            route_lines_batch
            .with(warp::compression::gzip())
        )
        .recover(routes::custom_rejection_handler)
        .with(wrap_fn(echo_x_request_id))
    ).unify();
    Ok(x.boxed())
}



#[tokio::main]
async fn main() -> Result<(), Box<dyn Error>> {
    
    // Read settings from command line of environment variables
    // see run with --help to see nice instructions generated by clap
    let settings:Settings = Settings::parse();

    // // Load data
    // let indexed_data:Arc<_> = IndexedData::load(
    //     &settings.NLR_DATA_FILE,
    //     &settings.NLR_DATA_SOURCE_URL,
    //     &settings.NLR_FORCE_UPDATE_DATA
    // ).await?.into();

    // // Define routes
    // let route_static_folder = warp::fs::dir(settings.NLR_STATIC_HTTP.clone());
    // let route_show = warp::path("show").and(route_static_folder);
    // let route_lines = routes::lines(indexed_data.clone());
    // let route_points = routes::points(indexed_data.clone());
    // let route_lines_batch = routes::lines_batch(indexed_data.clone());

    // // Build routes
    // let filter = route_show.or(
    //     route_lines
    //     .or(route_points)
    //     .or(
    //         route_lines_batch
    //         .with(warp::compression::gzip())
    //     )
    //     .recover(routes::custom_rejection_handler)
    //     .with(wrap_fn(echo_x_request_id))
    // );

    let filter = build_routes(&settings).await?;

    // Serve
    let address:SocketAddr = (settings.NLR_ADDR, settings.NLR_PORT).into();
    println!("Serving at {:?}", address);
    warp::serve(filter).run(address).await;

    Ok(())
}





#[cfg(test)]
mod main_tests {
    use crate::{build_routes, settings::Settings};

    /// every test is compiled and executed in a sandbox
    /// rust does not natively support fixtures for testing
    macro_rules! setup_routes_for_testing {
        () => {
            // modified settings for testing
            //  - prevent saving the data file by providing an empty filepath
            //  - set data source url to download a small subset of data
            //    (The first 5-ish kilometres of H015)
            build_routes(&Settings {
                NLR_DATA_FILE: "".to_owned(), 
                NLR_DATA_SOURCE_URL: "https://mrgis.mainroads.wa.gov.au/arcgis/rest/services/OpenData/RoadAssets_DataPortal/MapServer/17/query?where=ROAD%3D%27H015%27%20and%20END_SLK%3C5&outFields=ROAD,START_SLK,END_SLK,CWY&outSR=4326&f=json".to_owned(),
                ..Settings::default()
            }).await.unwrap()
        };
    }


    #[tokio::test]
    async fn basic_tests() {
        // download data and build routes
        let filter = setup_routes_for_testing!();

        // run a bunch of tests in this one function

        let result = warp::test::request().filter(&filter).await.unwrap();
        println!("{:?}", result);
        assert!(result.status().is_client_error());

        let result = warp::test::request().method("GET").path("/?road=H015").filter(&filter).await.unwrap();
        println!("{:?}", result);
        assert!(result.status().is_success());

        let result = warp::test::request().method("GET").path("/?road=H015&cwy=2").filter(&filter).await.unwrap();
        println!("{:?}", result);
        assert!(result.status().is_client_error());

        let result = warp::test::request().method("GET").path("/?road=H015&cway=L").filter(&filter).await.unwrap();
        println!("{:?}", result);
        assert!(result.status().is_client_error());

        // invalid method
        let result = warp::test::request().method("POST").path("/?road=H015").filter(&filter).await.unwrap();
        assert!(result.status().is_client_error());
    }
}